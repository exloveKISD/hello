<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Proxy Timeout Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, Arial, sans-serif; background: #0b1020; color: #e6e9f0; }
    .wrap { min-height: 100%; display: grid; place-items: center; padding: 2rem; }
    .card {
      max-width: 700px; width: 100%; background: #141a33; border: 1px solid #253056; border-radius: 16px;
      padding: 1.5rem; box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    h1 { margin: 0 0 .5rem; font-size: 1.4rem; }
    .muted { color: #9fb0d1; }
    .row { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
    .badge { padding: .3rem .6rem; border-radius: 999px; background: #1f2747; border: 1px solid #2e3b6b; font-variant-numeric: tabular-nums; }
    button {
      background: #2a3770; color: #fff; border: 1px solid #3a4aa0; border-radius: 10px; padding: .6rem .9rem; cursor: pointer;
    }
    button:hover { filter: brightness(1.15); }
    code { background: #1a2244; padding: .15rem .35rem; border-radius: 6px; border: 1px solid #2a3a7a; }
    hr { border: 0; border-top: 1px solid #253056; margin: 1rem 0; }
    .foot { font-size: .9rem; color: #9fb0d1; }
    .ok { color: #65e39a; }
    .warn { color: #ffda6b; }
    .err { color: #ff7b7b; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Proxy Timeout Test</h1>
      <p class="muted">
        This page loads a sub-resource that deliberately delays its response. Many proxies time out pages that
        haven’t fully loaded within their threshold (e.g., <strong>15 seconds</strong>). Use the controls below to choose a delay and watch the timer.
      </p>

      <div class="row">
        <span>Delay target:</span>
        <button data-delay="20000">20s</button>
        <button data-delay="30000">30s</button>
        <button data-delay="60000">60s</button>
        <span class="badge">Current: <span id="currentDelay">30,000</span> ms</span>
      </div>

      <hr />

      <div class="row">
        <div>Elapsed: <span class="badge" id="elapsed">0.0s</span></div>
        <div>Status:
          <span id="status" class="warn">Loading (waiting for delayed resource)…</span>
        </div>
      </div>

      <p class="foot">
        Notes: The page won’t fire <code>window.onload</code> until the delayed image finishes
        (or your proxy times out). If your network blocks <code>httpbin.org</code>, edit the source to use
        <code>https://httpstat.us/200?sleep=30000</code> (set <code>sleep</code> in ms), or point to an internal endpoint that can delay.
      </p>

      <!-- The delayed resource (hidden 1×1 image). Its URL is set by JS based on the selected delay. -->
      <img id="delayedImage" class="hidden" width="1" height="1" alt="delayed" />
    </div>
  </div>

  <script>
    // ------- Configuration helpers -------
    // Pick a default delay (ms). Start at 30s so it clearly exceeds a 15s proxy timeout.
    let delayMs = 30000;

    const delayedImg = document.getElementById('delayedImage');
    const currentDelay = document.getElementById('currentDelay');
    const statusEl = document.getElementById('status');
    const elapsedEl = document.getElementById('elapsed');

    // Build a delayed URL. Using httpbin: /delay/N returns after N seconds.
    // We request it as an <img>; the content-type won't be image, but the browser will
    // still wait for the HTTP response to finish or fail, which is what we want.
    function delayedUrl(ms) {
      const seconds = Math.ceil(ms / 1000); // httpbin accepts whole seconds
      return `https://httpbin.org/delay/${seconds}`;
      // Alternative if blocked:
      // return `https://httpstat.us/200?sleep=${ms}`; // sleep in milliseconds
    }

    // ------- Timer & state -------
    let startTime = null;
    let timerHandle = null;
    function startTimer() {
      startTime = performance.now();
      if (timerHandle) cancelAnimationFrame(timerHandle);
      function tick(now) {
        const s = (now - startTime) / 1000;
        elapsedEl.textContent = s.toFixed(1) + 's';
        timerHandle = requestAnimationFrame(tick);
      }
      timerHandle = requestAnimationFrame(tick);
    }
    function stopTimerAndMark(text, cls) {
      if (timerHandle) cancelAnimationFrame(timerHandle);
      statusEl.textContent = text;
      statusEl.className = cls;
    }

    // ------- Wiring -------
    function kickOffRequest() {
      currentDelay.textContent = delayMs.toLocaleString();
      statusEl.textContent = 'Loading (waiting for delayed resource)…';
      statusEl.className = 'warn';
      // Set the delayed URL and start counting
      delayedImg.src = delayedUrl(delayMs) + `?cacheBust=${Date.now()}`;
      startTimer();
    }

    // Buttons to switch delay
    document.querySelectorAll('button[data-delay]').forEach(btn => {
      btn.addEventListener('click', () => {
        delayMs = parseInt(btn.getAttribute('data-delay'), 10);
        kickOffRequest();
      });
    });

    // When the delayed image finally loads or errors, update status.
    delayedImg.addEventListener('load', () => {
      stopTimerAndMark('Completed: delayed resource returned (load event).', 'ok');
    });
    delayedImg.addEventListener('error', () => {
      // With httpbin, this will typically be 'error' because content-type != image,
      // but it still only fires after the delayed response arrives (or your proxy aborts it).
      stopTimerAndMark('Completed: delayed resource ended (error event after delay).', 'ok');
    });

    // Also listen for window onload to confirm page-level load completion.
    window.addEventListener('load', () => {
      // If we get here, the proxy did NOT time out before the delayed resource finished.
      // We’ll mark success only if the delayed resource already fired load/error.
      // (If the proxy kills the request, window.onload may never fire.)
      // No-op here; the image listeners above already mark completion.
    });

    // Start immediately with default delay.
    kickOffRequest();
  </script>
</body>
</html>
